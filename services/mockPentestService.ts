
import { PentestTargetInfo, PentestFinding, SecurityReport, PentestStatus, AdaptiveDefenseLogEntry, SimulatedDefenseBypassAttempt } from '../types';

const MOCK_FINDINGS_DATABASE: Omit<PentestFinding, 'id'>[] = [
  { 
    severity: 'Critical', 
    title: 'SQL Injection Vulnerability', 
    description: 'User input is directly incorporated into SQL queries, allowing for potential database manipulation via the "username" parameter on the login page.', 
    cwe: 'CWE-89', 
    recommendation: 'Implement parameterized queries or prepared statements for all database interactions. Validate and sanitize all user inputs rigorously using an allow-list approach.',
    mockEvidence: "Log Snippet:\\nMETHOD: POST /api/login\\nPARAMS: { 'username': 'admin\\' OR '1'='1', 'password': 'password' }\\nRESPONSE: 200 OK (User 'admin' logged in without valid password)",
    mockMitigationSteps: [
      "1. Review `authController.js` line 45: `const query = 'SELECT * FROM users WHERE username = \\'' + username + '\\' AND password = \\'' + password + '\\'';`",
      "2. Replace direct string concatenation with a parameterized query library function (e.g., `pg.query(text, values)`).",
      "3. Implement input validation to ensure `username` matches expected format (e.g., alphanumeric, specific length).",
      "4. Add server-side escaping for any dynamic parts of queries if parameterization is not fully possible (less ideal)."
    ],
    simulatedExploitPath: [
        "Attacker crafts malicious input: ' OR 1=1 --",
        "Input bypasses weak validation (if any).",
        "SQL query becomes: SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = '...'",
        "Database returns first user (often admin) or all users."
    ]
  },
  {
    severity: 'High',
    title: 'Cross-Site Scripting (XSS) - Stored',
    description: 'User-supplied data is stored and rendered on a page without proper sanitization, allowing attackers to inject malicious scripts.',
    cwe: 'CWE-79',
    recommendation: 'Implement context-aware output encoding for all user-supplied data. Use a security-focused templating engine or sanitize HTML with a robust library.',
    mockEvidence: 'User profile page displays <script>alert("XSS")</script> when visiting a compromised profile.',
    mockMitigationSteps: [
        "Identify all points where user input is displayed.",
        "Apply HTML entity encoding before rendering data in HTML context.",
        "Use Content Security Policy (CSP) to restrict script sources."
    ]
  },
  {
    severity: 'Medium',
    title: 'Insecure Direct Object References (IDOR)',
    description: 'Application uses direct user-supplied input to access objects, allowing attackers to enumerate and access unauthorized resources by manipulating identifiers.',
    cwe: 'CWE-639',
    recommendation: 'Implement access control checks for every resource request. Use indirect object references (e.g., session-mapped IDs) instead of direct database keys in URLs where possible.',
    mockEvidence: 'Accessing /api/documents/124 shows user A document. Accessing /api/documents/125 (belonging to user B) is successful for user A.',
    simulatedExploitPath: [
        "User A authenticates, notes document ID pattern.",
        "User A iterates document IDs (/api/documents/1, /api/documents/2, ...).",
        "User A successfully accesses documents not owned by them."
    ]
  }
];

export const generateMockSecurityReport = (targetInfo: PentestTargetInfo, productName: string): SecurityReport => {
  const numFindings = Math.floor(Math.random() * (MOCK_FINDINGS_DATABASE.length / 2)) + 2;
  const findings: PentestFinding[] = [];
  const usedIndices = new Set<number>();

  for (let i = 0; i < numFindings; i++) {
    let dbIndex;
    do {
      dbIndex = Math.floor(Math.random() * MOCK_FINDINGS_DATABASE.length);
    } while (usedIndices.has(dbIndex));
    usedIndices.add(dbIndex);
    
    const findingTemplate = MOCK_FINDINGS_DATABASE[dbIndex];
    // Explicitly construct the PentestFinding object
    const newFinding: PentestFinding = {
      id: `finding_${Date.now()}_${i}`,
      severity: findingTemplate.severity,
      title: findingTemplate.title,
      description: findingTemplate.description,
      cwe: findingTemplate.cwe,
      recommendation: findingTemplate.recommendation,
      mockEvidence: findingTemplate.mockEvidence,
      mockMitigationSteps: findingTemplate.mockMitigationSteps ? [...findingTemplate.mockMitigationSteps] : undefined,
      simulatedExploitPath: findingTemplate.simulatedExploitPath ? [...findingTemplate.simulatedExploitPath] : undefined,
    };
    findings.push(newFinding);
  }
  
  const severityScores: Record<PentestFinding['severity'], number> = {
    'Critical': 10, 'High': 7, 'Medium': 5, 'Low': 3, 'Informational': 1
  };
  const riskScores = findings.map(f => severityScores[f.severity] || 1);
  const overallRiskScore = findings.length > 0 ? parseFloat((riskScores.reduce((a,b) => a+b,0) / (findings.length * 10) * 10).toFixed(1)) : 0;

  // Generate mock adaptive defense logs if it's a "Project Chimera" service
  let adaptiveDefenseSimulation: AdaptiveDefenseLogEntry[] | undefined = undefined;
  let simulatedDefenseBypassAttempts: SimulatedDefenseBypassAttempt[] | undefined = undefined;

  if (productName.includes("Project Chimera")) {
      adaptiveDefenseSimulation = [
          { action: "Dynamic Firewall Rule Update", detail: "Blocked traffic from IP range 103.4.XX.XX due to anomalous request patterns.", simulatedEffect: "Prevents further scanning from identified C2 infrastructure.", confidence: "High" },
          { action: "AI-driven Honeypot Redirection", detail: "Suspicious actor probing /api/admin endpoint redirected to high-interaction honeypot.", simulatedEffect: "Gathers intelligence on attacker TTPs without exposing real systems.", confidence: "Medium" },
          { action: "Rate Limiting Protocol Engaged", detail: "Excessive login attempts for user 'root' triggered advanced rate limiting.", simulatedEffect: "Slows down brute-force attempts significantly.", confidence: "High"}
      ];
      simulatedDefenseBypassAttempts = [
          { technique: "IP Spoofing (Simulated)", targetDefenseAction: "Dynamic Firewall Rule Update", outcome: "Defense Held", detail: "Firewall identified and dropped spoofed packets based on heuristic analysis."},
          { technique: "Sophisticated SQLi Payload (Obfuscated)", targetDefenseAction: "WAF SQLi Filter", outcome: "Partially Bypassed", detail: "WAF blocked initial attempts, but a heavily obfuscated variant passed through, requiring deeper inspection (simulated manual review flagged it)."}
      ]
  }


  const report: SecurityReport = {
    reportId: `rep_backend_${Date.now()}`,
    targetSummary: targetInfo ? { ...targetInfo } : { scopeNotes: "Target information was not available." },
    executiveSummary: `This security assessment for ${productName} on target "${targetInfo?.targetUrl || targetInfo?.targetIp || 'N/A'}" was conducted by the Ckryptbit AI Core. Key findings include ${findings.length > 0 ? findings[0].title : 'no major issues'} and are detailed below. Remediation is advised.`,
    findings: findings.sort((a,b) => (severityScores[b.severity] || 0) - (severityScores[a.severity] || 0)),
    overallRiskScore: overallRiskScore,
    generatedDate: new Date(),
    methodology: 'Automated AI-driven analysis based on Ckryptbit proprietary algorithms and threat intelligence feeds (simulated for this report structure). Includes advanced heuristic pattern matching and common vulnerability enumeration checks.',
    adaptiveDefenseSimulation,
    simulatedDefenseBypassAttempts,
  };
  return report;
};

export const simulatePentestProcess = (
    updateStatusCallback: (status: PentestStatus) => void,
    delayPerStageMs: number = 100 
): Promise<void> => {
    console.warn("simulatePentestProcess is a mock and should be replaced by backend logic for production.");
    return new Promise(resolve => {
        const stages: PentestStatus[] = [
            'Information Gathering',
            'Vulnerability Scanning',
            'Analysis & Reporting',
        ];
        let currentStageIndex = 0;
        const nextStage = () => {
            if (currentStageIndex < stages.length) {
                updateStatusCallback(stages[currentStageIndex]);
                currentStageIndex++;
                setTimeout(nextStage, delayPerStageMs);
            } else {
                resolve(); 
            }
        };
        setTimeout(nextStage, delayPerStageMs / 2); 
    });
};
